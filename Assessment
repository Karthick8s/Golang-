package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"sync"

	"github.com/gin-gonic/gin"
)

type InputData struct {
	Ev     string `json:"ev"`
	Et     string `json:"et"`
	ID     string `json:"id"`
	UID    string `json:"uid"`
	MID    string `json:"mid"`
	T      string `json:"t"`
	P      string `json:"p"`
	L      string `json:"l"`
	SC     string `json:"sc"`
	ATRK1  string `json:"atrk1"`
	ATRV1  string `json:"atrv1"`
	ATRT1  string `json:"atrt1"`
	ATRK2  string `json:"atrk2"`
	ATRV2  string `json:"atrv2"`
	ATRT2  string `json:"atrt2"`
	UATRK1 string `json:"uatrk1"`
	UATRV1 string `json:"uatrv1"`
	UATRT1 string `json:"uatrt1"`
	UATRK2 string `json:"uatrk2"`
	UATRV2 string `json:"uatrv2"`
	UATRT2 string `json:"uatrt2"`
	UATRK3 string `json:"uatrk3"`
	UATRV3 string `json:"uatrv3"`
	UATRT3 string `json:"uatrt3"`
}

type OutputData struct {
	Event           string               `json:"event"`
	EventType       string               `json:"event_type"`
	AppID           string               `json:"app_id"`
	UserID          string               `json:"user_id"`
	MessageID       string               `json:"message_id"`
	PageTitle       string               `json:"page_title"`
	PageURL         string               `json:"page_url"`
	BrowserLanguage string               `json:"browser_language"`
	ScreenSize      string               `json:"screen_size"`
	Attributes      map[string]Attribute `json:"attributes"`
	Traits          map[string]Trait     `json:"traits"`
}

type Attribute struct {
	Value string `json:"value"`
	Type  string `json:"type"`
}

type Trait struct {
	Value string `json:"value"`
	Type  string `json:"type"`
}

var (
	requestChannel = make(chan InputData)
	wg             sync.WaitGroup
)

func main() {

	router := gin.Default()

	router.Post("/enter", func(c *gin.Context) {
		var requestData InputData
		if err := c.BindJSON(&requestData); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}
		wg.Add(1)
		go func() {
			defer wg.Done()
			requestChannel <- requestData
		}()
		c.JSON(http.StatusOK, gin.H{"message": "Request Received"})
	})

	go func() {
		fmt.Println("Server is running")
		router.Run(":8080")

	}()

	go func() {
		for {

			requestData := <-requestChannel
			outputData := transformRequest(requestData)

			//Print statement for processing data
			fmt.Println("Transform Data :", outputData)
		}

	}()

	wg.Wait()

}

//Transform request to the desired format

func transformRequest(input InputData) OutputData {
	output := OutputData{
		Event:           input.Ev,
		EventType:       input.Et,
		AppID:           input.ID,
		UserID:          input.UID,
		MessageID:       input.MID,
		PageTitle:       input.T,
		PageURL:         input.P,
		BrowserLanguage: input.L,
		ScreenSize:      input.SC,
		Attributes: map[string]Attribute{
			input.ATRK1: {Value: input.ATRV1, Type: input.ATRT1},
			input.ATRK2: {Value: input.ATRV2, Type: input.ATRT2},
		},
		Traits: map[string]Trait{
			input.UATRK1: {Value: input.UATRV1, Type: input.UATRT1},
			input.UATRK2: {Value: input.UATRV2, Type: input.UATRT2},
			input.UATRK3: {Value: input.UATRV3, Type: input.UATRT3},
		},
	}

	return output
}

// send transform data to webhook site
func sendToWebhook(output OutputData) {
	jsonData, err := json.Marshal(output)
	if err != nil {
		fmt.Println("Error marshalling JSON:", err)
		return
	}

	response, err := http.Post("https://webhook.site/f90c73e4-3866-4637-93e8-81e9cb2beb36", "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		fmt.Println("Error sending data to webhook endpoint:", err)
		return
	}

	defer response.Body.Close()

	fmt.Println("Response from webhook endpoint:", response.Status)
}
